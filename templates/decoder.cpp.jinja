# macro bit_str(bit)
{{"%s" % bit.value}}
#- endmacro

# macro pad_left_bit_pos(bit_pos)
{{"%2s" | format(bit_pos)}}
#- endmacro

# macro encoding(enc)
// {{ enc.instruction.name }} [{{enc.instruction.fileName}}]
opcode = aarch64_a64_{{ enc.instruction.mnemonic | lower }};
length = 4;
# for bs in enc.named_bit_sequences()
  # if bs.width == 1
((aarch64_decode_a64_<???>&)*this).{{bs.name}} = BITSEL(ir, {{bs.high_bit}});
  # else
((aarch64_decode_a64_<???>&)*this).{{bs.name}} = UNSIGNED_BITS(ir, {{bs.high_bit}},{{bs.low_bit}});
  # endif
# endfor
((aarch64_decode_a64_<???>&)*this).decode_behaviour();
return True;
#- endmacro

bool aarch64_decode::decode_a64(uint32_t ir)
{
  # for enc_set in sets
  if(
    #- for bit_pos, bit_val in enc_set.ordered_shared_bits()
      #- if loop.index0 != 0
   &&
      #- endif
 (((ir >> {{pad_left_bit_pos(bit_pos)}}) & 1) == {{bit_str(bit_val)}})
    # endfor
  ) {
  # if not enc_set.is_singleton()
    # for enc in enc_set.encodingsOrderedByIncreasingUnbound()
    # set bound_bits = drop_unbound_from_pos_map(enc.getBitMany(enc_set.findUncommonlyBoundBits())).items()
    # if list(bound_bits) != []
    if(
      #- for bit_pos, (_, bit_val) in bound_bits
      #- if loop.index0 != 0
     &&
      #- endif
 (((ir >> {{pad_left_bit_pos(bit_pos)}}) & 1) == {{bit_str(bit_val)}})
      # endfor
    ) {
      {{ encoding(enc) | indent(6) }}
    }
    # else
    {{ encoding(enc) | indent }}
    # endif
    # endfor
  # else
    # set enc = enc_set.encodings.pop()
    {{ encoding(enc) | indent }}
  # endif
  }
  # endfor
  return false;
}